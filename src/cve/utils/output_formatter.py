# SPDX-FileCopyrightText: Copyright (c) 2024, NVIDIA CORPORATION & AFFILIATES. All rights reserved.
# SPDX-License-Identifier: Apache-2.0
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import os
import html
from typing import Union
from datetime import datetime
from ..data_models.output import AgentMorpheusOutput


def generate_vulnerability_reports(model_dict: AgentMorpheusOutput, output_dir):
    """
    Creates a markdown file for each CVE ID in the markdown content dictionary.

    Parameters
    ----------
    model_dict : AgentMorpheusOutput
        JSON data containing vulnerability information.
    output_dir : str
        The directory where the markdown files will be created.

    Returns
    -------
    None
    """
    markdown_content = _transform_to_markdown(model_dict)

    # Get the container directory name based on the image name and tag
    container_dir_name = (
        model_dict.input.image.name.split("/")[-1].replace(".", "_")
        + "_"
        + model_dict.input.image.tag.replace(".", "_")
    )

    # Create a subdirectory named after the prefixed container ID inside the output_dir
    container_dir = os.path.join(
        output_dir, f"vulnerability_reports_{container_dir_name}"
    )

    if not os.path.exists(container_dir):
        os.makedirs(container_dir, exist_ok=True)

    for cve_id, content in markdown_content.items():
        file_name = f"{cve_id}.md"
        file_path = os.path.join(container_dir, file_name)
        with open(file_path, "w") as f:
            f.write("\n".join(content))


def _transform_to_markdown(model_dict: AgentMorpheusOutput):
    """
    Convert JSON data to Markdown content.

    Parameters
    ----------
    model_dict : AgentMorpheusOutput
        JSON data containing vulnerability information.

    Returns
    -------
    dict
        Markdown content for each CVE ID.
    """
    cve_ids = [vuln.vuln_id for vuln in model_dict.input.scan.vulns]
    markdown_content = {}
    for cve_id in cve_ids:
        markdown_content[cve_id] = []

    _add_header(markdown_content, model_dict)
    _add_cve_intel(markdown_content, model_dict)
    _add_vulnerability_analysis(markdown_content, model_dict)
    _add_table_of_contents(markdown_content, model_dict)
    _add_checklist_info(markdown_content, model_dict)
    _add_vulnerable_sboms(markdown_content, model_dict)
    _add_references(markdown_content, model_dict)
    return markdown_content


def _add_header(markdown_content, model_dict: AgentMorpheusOutput):
    """
    Add header to Markdown content.

    Parameters
    ----------
    markdown_content : dict
        Markdown content for each CVE ID.
    model_dict : AgentMorpheusOutput
        JSON data containing vulnerability information.

    Returns
    -------
    None
        This function modifies `markdown_content` in place.
    """
    input_image = model_dict.input.image
    # iterate over a list of dict objects, with vuln_id and ghsa being 2 keys in each element
    for output in model_dict.output:
        cve_id = output.vuln_id
        markdown_content[cve_id].append(f"# Vulnerability Analysis Report for {cve_id}")
        markdown_content[cve_id].append(
            f"> **Container Analyzed:** `{input_image.name} : {input_image.tag}`\n\n"
        )
        # Only add SBOM info if it is a file location
        if input_image.sbom_info.type == "file":
            markdown_content[cve_id].append(
                f"> **SBOM Info:** `{input_image.sbom_info}`\n\n"
            )
        markdown_content[cve_id].append(
            f"> **Status:**: {_get_expoiltability_text(output.justification.status)}"
        )


def _add_cve_intel(markdown_content, model_dict: AgentMorpheusOutput):
    """
    Add CVE intelligence details to Markdown content.

    Parameters
    ----------
    markdown_content : dict
        Markdown content for each CVE ID.
    model_dict : AgentMorpheusOutput
        JSON data containing vulnerability information.

    Returns
    -------
    None
        This function modifies `markdown_content` in place.
    """
    for intel_obj in model_dict.info.intel:
        cve_id = intel_obj.vuln_id
        cve_description = _process_description_by_type(_get_cve_description(intel_obj))
        markdown_content[cve_id].append(f"## {cve_id}")
        # add a disputed tag if nvd.disputed is true
        intel_obj.nvd.disputed and markdown_content[cve_id].append(
            "<span style=\"color:#ffa500\">`Disputed`<span>"
        )
        markdown_content[cve_id].append(_get_cve_dates(intel_obj))

        cve_description and markdown_content[cve_id].append(
            f"\n\n {cve_description} \n"
        )

        cve_severity_ratings = _get_cve_severity(intel_obj)
        cve_severity_ratings and markdown_content[cve_id].append(
            f"\n{cve_severity_ratings} \n"
        )
        markdown_content[cve_id].append(add_epss_score(intel_obj))


def _get_cve_severity(intel_obj):
    """
    Extract CVE severity and construct a markdown table.

    Parameters
    ----------
    intel_obj : object
        An object containing CVE severity details from multiple sources.

    Returns
    -------
    str
        A markdown-formatted table summarizing CVE severity and vector strings.
    """
    # Extracting data from GHSA
    ghsa_severity = _safe_getattr(intel_obj, "ghsa.severity", "N/A").capitalize()
    ghsa_cvss_score = _safe_getattr(intel_obj, 'ghsa.cvss.score', 'N/A')
    ghsa_vector = _safe_getattr(intel_obj, 'ghsa.cvss.vector_string', 'N/A')

    # Extracting data from NVD
    nvd_severity = _safe_getattr(intel_obj, "nvd.cvss_severity", "N/A").capitalize()
    nvd_cvss_score = _safe_getattr(intel_obj, 'nvd.cvss_base_score', 'N/A')
    nvd_vector = _safe_getattr(intel_obj, 'nvd.cvss_vector', 'N/A')

    # Extracting data from Red Hat (RHSA)
    rhsa_severity = _safe_getattr(intel_obj, "rhsa.threat_severity", "N/A").capitalize()
    rhsa_cvss_score = _safe_getattr(intel_obj, 'rhsa.cvss3.cvss3_base_score', "N/A")
    rhsa_vector = _safe_getattr(intel_obj, 'rhsa.cvss3.cvss3_scoring_vector', "N/A")

    # Extracting data from Ubuntu
    ubuntu_severity = _safe_getattr(intel_obj, 'ubuntu.impact.baseMetricV3.cvssV3.baseSeverity', "N/A").capitalize()
    ubuntu_cvss_score = _safe_getattr(intel_obj, 'ubuntu.impact.baseMetricV3.cvssV3.baseScore', "N/A")
    ubuntu_vector = _safe_getattr(intel_obj, 'ubuntu.impact.baseMetricV3.cvssV3.vectorString', "N/A")

    # Constructing the markdown table
    markdown_table = ["### CVSS Severity and Vector Strings\n"]
    markdown_table.append("| Source     | Severity  | CVSS Score | Vector |\n")
    markdown_table.append("|---|---|---|---|\n")
    markdown_table.append(f"| **GHSA** |{ghsa_severity}|{ghsa_cvss_score}|{ghsa_vector}|\n")
    markdown_table.append(f"| **NVD** |{nvd_severity}|{nvd_cvss_score}|{nvd_vector}|\n")
    markdown_table.append(f"| **RHSA** |{rhsa_severity}|{rhsa_cvss_score}|{rhsa_vector}|\n")
    markdown_table.append(f"| **Ubuntu** |{ubuntu_severity}|{ubuntu_cvss_score}|{ubuntu_vector}|\n")

    return "".join(markdown_table)


def _get_cve_dates(intel_obj):
    """
    Retrieve published and last updated dates for a CVE.

    Parameters
    ----------
    intel_obj : object
        An object with CVE information from multiple sources.

    Returns
    -------
    str
        A markdown-formatted string with published and last updated dates.
    """
    # use NVD as a backup source for dates
    published_at = _convert_timestamp_to_human_readable(
        _safe_getattr(intel_obj, 'ghsa.published_at', intel_obj.nvd.published_at)
    )
    updated_at = _convert_timestamp_to_human_readable(
        _safe_getattr(intel_obj, 'ghsa.updated_at', intel_obj.nvd.updated_at)
    )
    return f"\n> Published: **{published_at}** <br> Last Updated: **{updated_at}**"


def add_epss_score(intel_obj):
    """
    Retrieve EPSS data for the cve.

    Parameters
    ----------
    intel_obj : object
        An object with CVE information from multiple sources.

    Returns
    -------
    str
        A markdown-formatted string with a table for EPSS data
    """
    # Create a markdown table for EPSS data
    table = "### EPSS Score\n"
    table += "| EPSS | Percentile |\n| --- | --- |\n"
    table += f"| {intel_obj.epss.epss} | {intel_obj.epss.percentile} |\n"

    # Append the markdown table to the specified CVE ID
    return table


def _get_cve_description(intel_obj):
    """
    Retrieve a description for a CVE from multiple sources.

    Parameters
    ----------
    intel_obj : object
        An object containing CVE details from various sources (e.g., GHSA, NVD).

    Returns
    -------
    str or None
        A string description of the CVE or None if no description is found.
    """
    if intel_obj.ghsa and intel_obj.ghsa.description:
        return intel_obj.ghsa.description
    if intel_obj.rhsa and intel_obj.rhsa.details:
        return intel_obj.rhsa.details
    if intel_obj.ubuntu and intel_obj.ubuntu.description:
        return intel_obj.ubuntu.description
    if intel_obj.nvd and intel_obj.nvd.cve_description:
        return intel_obj.nvd.cve_description

    return None


def _add_table_of_contents(markdown_content, model_dict: AgentMorpheusOutput):
    """
    Add a table of contents for checklists per CVE.

    Parameters
    ----------
    markdown_content : dict
        Markdown content for each CVE ID.
    model_dict : AgentMorpheusOutput
        JSON data containing vulnerability information.

    Returns
    -------
    None
        This function modifies `markdown_content` in place.
    """
    for entry in model_dict.output:
        cve_id = entry.vuln_id
        checklist = entry.checklist
        markdown_content[cve_id].append(
            "## Table of Contents <a name='toc' id='toc'></a>\n"
        )
        markdown_content[cve_id].append(
            "#### [Checklist](#checklist) <a name='checklist-toc' id='checklist-toc'></a>"
        )
        if checklist:
            steps = {
                item.input.split(":")[0]: [
                    intermediate_step.tool_name
                    for intermediate_step in item.intermediate_steps or []
                ]
                for item in checklist
            }
            for i, (step, intermediate_steps) in enumerate(steps.items(), start=1):
                markdown_content[cve_id].append(f"{i}. [{step}](#checklist-step-{i})\n")
                for j, intermediate_step in enumerate(intermediate_steps, start=1):
                    markdown_content[cve_id].append(
                        f"\t {j}. [{intermediate_step}](#checklist-step-{i}.{j})"
                    )
        markdown_content[cve_id].append(
            "#### [Vulnerable SBOMS](#sbom) <a name='sbo-toc' id='checklist-toc'></a>"
        )


def _add_checklist_info(markdown_content, model_dict: AgentMorpheusOutput):
    """
    Add detailed information for checklists associated with each CVE.

    Parameters
    ----------
    markdown_content : dict
        Markdown content for each CVE ID.
    model_dict : AgentMorpheusOutput
        JSON data containing vulnerability information.

    Returns
    -------
    None
        This function modifies `markdown_content` in place.
    """
    for entry in model_dict.output:
        cve_id = entry.vuln_id
        checklist = entry.checklist
        if checklist:
            markdown_content[cve_id].append(
                f"\n## Checklist Details <a name='checklist' id='checklist'></a>"
            )
            for i, item in enumerate(checklist, start=1):
                input_text = item.input
                response = item.response
                markdown_content[cve_id].append(
                    f"\n## Step {i} <a name='checklist-step-{i}' id='checklist-step-{i}'></a> : {input_text.split(':')[0]}\n"
                )
                markdown_content[cve_id].append(f"\n> **Input**: *{input_text}*")
                markdown_content[cve_id].append(f"\n> **Response**: *{response}*")
                intermediate_steps = item.intermediate_steps
                if intermediate_steps:
                    for j, step in enumerate(intermediate_steps, start=1):
                        tool_name = step.tool_name
                        action_log = step.action_log
                        tool_input = step.tool_input
                        tool_output = step.tool_output
                        markdown_content[cve_id].append(
                            f"\n### Step {i}.{j} : *{tool_name}*<a name='checklist-step-{i}.{j}' id='checklist-step-{i}.{j}'></a>"
                        )
                        markdown_content[cve_id].append(
                            f"\n\n#### Action Log \n<pre>{action_log} </pre>"
                        )
                        markdown_content[cve_id].append(
                            f"\n\n#### Tool Input \n<pre>{tool_input} </pre>"
                        )
                        markdown_content[cve_id].append(
                            f"\n\n#### Tool Output \n{_process_tool_output(tool_output)}\n\n"
                        )
                        if j != len(intermediate_steps):
                            markdown_content[cve_id].append(
                                "\n[back to top](#checklist-toc)"
                            )
                elif not intermediate_steps and i != len(checklist):
                    markdown_content[cve_id].append("\n[back to top](#checklist-toc)")

            markdown_content[cve_id].append("\n[back to top](#checklist-toc)")


def _process_tool_output(content):
    """
    Process the tool output content and return a renderable markdown object.

    Parameters
    ----------
    content : dict or str
        JSON or string object representing tool output.

    Returns
    -------
    str
        Renderable markdown representation of the tool output.
    """
    if isinstance(content, str):
        return f"<pre>{content}</pre>"
    result = content.get("result", "")
    content_markdown = ""
    if result:
        content_markdown += f"> **Response:** {result}"
    metadata_keys = set()
    for item in content.get("source_documents", []):
        if "metadata" in item:
            metadata_keys.update(item["metadata"].keys())
    table = (
        "\n\n Source Documents \n\n | ID | Type | "
        + " |... ".join(metadata_keys)
        + " | Page Content |\n"
    )
    table += "| --- " * (len(metadata_keys) + 3) + "|\n"
    for item in content.get("source_documents", []):
        row = [str(item.get("id", "")), str(item.get("type", ""))]
        for key in metadata_keys:
            row.append(str(item.get("metadata", {}).get(key, "")))
        # Retrieve and sanitize page content
        page_content = item.get("page_content", "")
        # # Remove extra whitespace
        page_content = " ".join(page_content.split())
        # Escape special characters
        page_content = html.escape(page_content)
        row.append(
            f"<details><summary>View Content</summary><pre>{_process_description_by_type(page_content)}</pre></details>"
        )
        table += "| " + " | ".join(row) + " |\n"
    return content_markdown + table


def _add_vulnerability_analysis(markdown_content, model_dict: AgentMorpheusOutput):
    """
    Add vulnerability analysis details to Markdown content.

    Parameters
    ----------
    markdown_content : dict
        Markdown content for each CVE ID.
    model_dict : AgentMorpheusOutput
        JSON data containing vulnerability information.

    Returns
    -------
    None
        This function modifies `markdown_content` in place.
    """
    for entry in model_dict.output:
        cve_id = entry.vuln_id
        summary = entry.summary
        justification = entry.justification
        exploitability = justification.status
        exploitability_text = _get_expoiltability_text(exploitability)
        markdown_content[cve_id].append("## Analysis\n")
        markdown_content[cve_id].append(
            f"### Summary <a name='summary' id='summary'></a>({exploitability_text})\n{summary}"
        )
        markdown_content[cve_id].append(
            f"\n### Justification <a name='justification' id='justification'></a> \n"
        )
        markdown_content[cve_id].append(f"\n>label: {justification.label}")
        markdown_content[cve_id].append(f"\n{justification.reason}")


def _add_vulnerable_sboms(markdown_content, model_dict: AgentMorpheusOutput):
    """
    Add information about vulnerable SBOM dependencies to Markdown content.

    Parameters
    ----------
    markdown_content : dict
        Markdown content for each CVE ID.
    model_dict : AgentMorpheusOutput
        JSON data containing vulnerability information.

    Returns
    -------
    None
        This function modifies `markdown_content` in place.
    """
    vulnerable_sboms_per_cve_id = {
        i.vuln_id: i.vulnerable_sbom_packages
        for i in model_dict.info.vulnerable_dependencies
    }

    for cve_id, vulnerable_sboms in vulnerable_sboms_per_cve_id.items():
        markdown_content[cve_id].append(
            "\n---\n## Vulnerable SBOM Dependencies <a name='sbom' id='sbom'></a> \n"
        )

        # Add table header
        markdown_content[cve_id].append(
            "\n| SBOM Name | SBOM Version | Dependency Name | Dependency Version | Relation | System |\n| --- | --- | --- | --- | --- | --- |"
        )

        # Create a set to track unique rows
        unique_rows = set()

        # Add rows for each SBOM entry
        for sbom in vulnerable_sboms:
            dependency = sbom.vulnerable_dependency_package
            row = f"| {sbom.name} | {sbom.version} | {dependency.name} | {dependency.version} | {dependency.relation} | {dependency.system} |"
            # Check if the row is unique before adding it
            if row not in unique_rows:
                markdown_content[cve_id].append(row)
                unique_rows.add(row)  # Add the row to the set of unique rows

        # Add a back-to-top link after the table
        markdown_content[cve_id].append("\n[back to top](#toc)\n")
        
def _add_references(markdown_content, model_dict: AgentMorpheusOutput):
    """
    Add references for a CVE from all available sources in the intel object.

    Parameters
    ----------
    markdown_content : dict
        Markdown content for each CVE ID.
    model_dict : AgentMorpheusOutput
        JSON data containing references information.

    Returns
    -------
    None
        This function modifies `markdown_content` in place.
    """
    for intel_obj in model_dict.info.intel:
        cve_id = intel_obj.vuln_id
        markdown_content[cve_id].append(
            "\n---\n## References <a name='ref' id='ref'></a>  \nHere are key references for further details on this vulnerability:"
        )
        references = set()
        for source in ["ghsa", "nvd", "rhsa", "ubuntu"]:
            references.update(_get_formatted_references(_safe_getattr(intel_obj, f"{source}.references", [])))

        references_content = "\n".join(["- "+reference for reference in list(references)])
        markdown_content[cve_id].append(references_content)


def _get_formatted_references(references: list):
    """
    Format and clean up references by splitting multiline strings into individual entries.

    Parameters
    ----------
    references : list
        A list of reference strings or objects.

    Returns
    -------
    list
        A cleaned and formatted list of references.
    """
    for index, element in enumerate(references):
        # Check if the element is a string and contains '\n'
        if isinstance(element, str) and '\n' in element:
            # Split the string by '\n' and replace it in the list
            split_strings = element.split('\n')
            references[index:index+1] = split_strings
    return references


def _get_expoiltability_text(exploitability: str):
    """
    Get a color-coded text label based on the exploitability status.

    Parameters
    ----------
    exploitability : str
        Exploitability status (e.g., "TRUE", "FALSE", or unknown).

    Returns
    -------
    str
        HTML-formatted string with a color-coded label indicating exploitability.
    """
    color = "#9E9E9E"  # Gray
    exploitability_text = "Exploitability Unknown"
    if exploitability == "TRUE":
        color = "#F44336"  # Red
        exploitability_text = "Exploitable"
    elif exploitability == "FALSE":
        color = "#4CAF50"  # Green
        exploitability_text = "Not Exploitable"
    return f"<span style='color:{color}'>{exploitability_text}</span>"


def _process_description_by_type(description: Union[str, list]):
    """
    Process cve description to handle different formats (string or list).

    Parameters
    ----------
    description : str or list
        The description to process, which can be a string or a list of strings.

    Returns
    -------
    str
        A markdown-formatted string representing the processed description.
    """
    if isinstance(description, list):
        markdown_list = "\n".join([f"- {item}" for item in description])
        return markdown_list

    # Check if it's a string and contains markdown syntax
    elif isinstance(description, str):
        # Simple check for common markdown characters (you can expand this)
        markdown_indicators = ["\n", "\n#"]

        if any(indicator in description for indicator in markdown_indicators):
            # Return the string wrapped in triple backticks (code block)
            return f"```\n{description}\n```"

        # If it's just a normal string, return it as-is
        return description

    return None


# Function to safely access deeply nested attributes
def _safe_getattr(obj, attr_path, default=None):
    """
    Safely access deeply nested attributes in an object.

    Parameters
    ----------
    obj : object
        The object from which to retrieve attributes.
    attr_path : str
        Dot-separated string representing the path to the attribute.
    default : any, optional
        The default value to return if the attribute does not exist.

    Returns
    -------
    any
        The value of the nested attribute or the default value if not found.
    """
    attrs = attr_path.split('.')
    for attr in attrs:
        obj = getattr(obj, attr, default)
        if obj is default:
            break
    return obj


def _convert_timestamp_to_human_readable(timestamp: str | None):
    """
    Convert a timestamp string into a human-readable format.

    Parameters
    ----------
    timestamp : str or None
        The timestamp string in various formats.

    Returns
    -------
    str or None
        The formatted timestamp or None if conversion fails.
    """
    if not timestamp:
        return None
    # List of possible date formats
    date_formats = [
        "%Y-%m-%dT%H:%M:%SZ",       # ISO 8601 format with 'Z'
        "%Y-%m-%dT%H:%M:%S.%f",     # ISO 8601 format with milliseconds
        "%Y-%m-%d %H:%M:%S",        # Standard format without 'T' or 'Z'
        "%d/%m/%Y %H:%M:%S",        # Example alternative format
    ]

    for fmt in date_formats:
        try:
            return datetime.strptime(timestamp, fmt).strftime("%Y-%m-%d")
        except ValueError:
            continue  # Try the next format

    return None
